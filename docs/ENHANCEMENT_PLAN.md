# ‡πÅ‡∏ú‡∏ô‡∏Å‡∏≤‡∏£‡∏û‡∏±‡∏í‡∏ô‡∏≤‡∏ï‡πà‡∏≠‡∏¢‡∏≠‡∏î‡∏£‡∏∞‡∏ö‡∏ö PostXAgent

**‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏õ‡∏£‡∏∞‡∏™‡∏á‡∏Ñ‡πå**: ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ AI Video Generation ‡πÅ‡∏•‡∏∞ Music Generation ‡∏•‡∏á‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà
**‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà**: 24 ‡∏ò‡∏±‡∏ô‡∏ß‡∏≤‡∏Ñ‡∏° 2025
**‡πÄ‡∏ß‡∏≠‡∏£‡πå‡∏ä‡∏±‡∏ô**: 2.0.0

---

## üìã ‡∏™‡∏≤‡∏£‡∏ö‡∏±‡∏ç

1. [‡∏†‡∏≤‡∏û‡∏£‡∏ß‡∏°‡∏Å‡∏≤‡∏£‡∏û‡∏±‡∏í‡∏ô‡∏≤](#‡∏†‡∏≤‡∏û‡∏£‡∏ß‡∏°‡∏Å‡∏≤‡∏£‡∏û‡∏±‡∏í‡∏ô‡∏≤)
2. [‡∏ü‡∏µ‡πÄ‡∏à‡∏≠‡∏£‡πå‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏û‡∏¥‡πà‡∏°](#‡∏ü‡∏µ‡πÄ‡∏à‡∏≠‡∏£‡πå‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏û‡∏¥‡πà‡∏°)
3. [‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á‡πÉ‡∏ô Core Models](#‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á‡πÉ‡∏ô-core-models)
4. [Platform Workers ‡πÉ‡∏´‡∏°‡πà](#platform-workers-‡πÉ‡∏´‡∏°‡πà)
5. [FFmpeg Integration](#ffmpeg-integration)
6. [Queue System Enhancement](#queue-system-enhancement)
7. [API Endpoints](#api-endpoints)
8. [UI Components](#ui-components)
9. [Database Schema](#database-schema)
10. [Timeline](#timeline)

---

## ‡∏†‡∏≤‡∏û‡∏£‡∏ß‡∏°‡∏Å‡∏≤‡∏£‡∏û‡∏±‡∏í‡∏ô‡∏≤

### üéØ ‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢

‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÉ‡∏´‡∏°‡πà‡∏•‡∏á‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö PostXAgent ‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÅ‡∏•‡∏∞ Web Learning Engine ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß:

1. **AI Video Generation** - ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ß‡∏µ‡∏î‡∏µ‡πÇ‡∏≠‡∏î‡πâ‡∏ß‡∏¢ AI (Freepik, Runway, Pika, Luma)
2. **AI Music Generation** - ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÄ‡∏û‡∏•‡∏á‡∏î‡πâ‡∏ß‡∏¢ AI (Suno AI)
3. **Media Processing** - ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏ß‡∏µ‡∏î‡∏µ‡πÇ‡∏≠‡πÅ‡∏•‡∏∞‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏î‡πâ‡∏ß‡∏¢ FFmpeg
4. **Video & Music Mixing** - ‡∏ú‡∏™‡∏°‡∏ß‡∏µ‡∏î‡∏µ‡πÇ‡∏≠‡∏Å‡∏±‡∏ö‡πÄ‡∏û‡∏•‡∏á

### üèóÔ∏è ‡∏™‡∏ñ‡∏≤‡∏õ‡∏±‡∏ï‡∏¢‡∏Å‡∏£‡∏£‡∏°‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà

```
AIManagerCore/
‚îú‚îÄ‚îÄ src/AIManager.Core/
‚îÇ   ‚îú‚îÄ‚îÄ Models/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Enums.cs                    ‚ö†Ô∏è ‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏û‡∏¥‡πà‡∏° enum
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ TaskItem.cs                 ‚ö†Ô∏è ‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏û‡∏¥‡πà‡∏° properties
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îÇ   ‚îú‚îÄ‚îÄ Workers/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ BasePlatformWorker.cs       ‚úÖ ‡πÉ‡∏ä‡πâ‡∏ã‡πâ‡∏≥‡πÑ‡∏î‡πâ
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ PlatformWorkers.cs          ‚ö†Ô∏è ‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏û‡∏¥‡πà‡∏° workers
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ WorkerFactory.cs            ‚ö†Ô∏è ‡∏ï‡πâ‡∏≠‡∏á‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó
‚îÇ   ‚îú‚îÄ‚îÄ WebAutomation/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ BrowserController.cs        ‚úÖ ‡πÉ‡∏ä‡πâ‡πÑ‡∏î‡πâ‡πÄ‡∏•‡∏¢
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ WorkflowLearningEngine.cs   ‚úÖ ‡πÉ‡∏ä‡πâ‡πÑ‡∏î‡πâ‡πÄ‡∏•‡∏¢
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ WorkflowExecutor.cs         ‚úÖ ‡πÉ‡∏ä‡πâ‡πÑ‡∏î‡πâ‡πÄ‡∏•‡∏¢
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ...                         ‚úÖ ‡πÉ‡∏ä‡πâ‡∏ó‡∏∏‡∏Å‡πÑ‡∏ü‡∏•‡πå‡πÑ‡∏î‡πâ‡πÄ‡∏•‡∏¢
‚îÇ   ‚îú‚îÄ‚îÄ Services/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ AIBrainService.cs           ‚úÖ ‡πÉ‡∏ä‡πâ‡πÑ‡∏î‡πâ‡πÄ‡∏•‡∏¢
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ContentGeneratorService.cs  ‚úÖ ‡πÉ‡∏ä‡πâ‡πÑ‡∏î‡πâ‡πÄ‡∏•‡∏¢
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îÇ   ‚îî‚îÄ‚îÄ NEW: MediaProcessing/           ‚ùå ‡∏ï‡πâ‡∏≠‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÉ‡∏´‡∏°‡πà
‚îÇ       ‚îú‚îÄ‚îÄ FFmpegService.cs
‚îÇ       ‚îú‚îÄ‚îÄ VideoProcessor.cs
‚îÇ       ‚îú‚îÄ‚îÄ AudioProcessor.cs
‚îÇ       ‚îî‚îÄ‚îÄ MixingService.cs
```

---

## ‡∏ü‡∏µ‡πÄ‡∏à‡∏≠‡∏£‡πå‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏û‡∏¥‡πà‡∏°

### ‚úÖ ‡∏™‡∏¥‡πà‡∏á‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß (‡πÉ‡∏ä‡πâ‡∏ã‡πâ‡∏≥‡πÑ‡∏î‡πâ)

| Component | ‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ | ‡πÉ‡∏ä‡πâ‡∏Å‡∏±‡∏ö Video/Music ‡πÑ‡∏î‡πâ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà |
|-----------|------|------------------------------|
| **Web Learning System** | ‚úÖ Complete | ‚úÖ ‡πÉ‡∏ä‡πâ‡πÑ‡∏î‡πâ‡πÄ‡∏•‡∏¢ - ‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡∏ó‡∏∏‡∏Å platform |
| **BrowserController** | ‚úÖ Complete | ‚úÖ ‡πÉ‡∏ä‡πâ‡πÑ‡∏î‡πâ‡πÄ‡∏•‡∏¢ - Playwright automation |
| **WorkflowLearningEngine** | ‚úÖ Complete | ‚úÖ ‡πÉ‡∏ä‡πâ‡πÑ‡∏î‡πâ‡πÄ‡∏•‡∏¢ - ‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡∏£‡∏π‡πâ workflow ‡πÉ‡∏î‡πÜ ‡∏Å‡πá‡πÑ‡∏î‡πâ |
| **WorkflowExecutor** | ‚úÖ Complete | ‚úÖ ‡πÉ‡∏ä‡πâ‡πÑ‡∏î‡πâ‡πÄ‡∏•‡∏¢ - Execute workflows |
| **AIElementAnalyzer** | ‚úÖ Complete | ‚úÖ ‡πÉ‡∏ä‡πâ‡πÑ‡∏î‡πâ‡πÄ‡∏•‡∏¢ - ‡∏´‡∏≤ elements ‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥ |
| **VisualElementRecognizer** | ‚úÖ Complete | ‚úÖ ‡πÉ‡∏ä‡πâ‡πÑ‡∏î‡πâ‡πÄ‡∏•‡∏¢ - Visual matching |
| **WorkflowStorage** | ‚úÖ Complete | ‚úÖ ‡πÉ‡∏ä‡πâ‡πÑ‡∏î‡πâ‡πÄ‡∏•‡∏¢ - ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å workflows |
| **BasePlatformWorker** | ‚úÖ Complete | ‚úÖ ‡πÉ‡∏ä‡πâ‡πÑ‡∏î‡πâ‡πÄ‡∏•‡∏¢ - Base class |
| **TaskItem/TaskResult** | ‚ö†Ô∏è Partial | ‚ö†Ô∏è ‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏û‡∏¥‡πà‡∏° properties |
| **Enums** | ‚ö†Ô∏è Partial | ‚ö†Ô∏è ‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏û‡∏¥‡πà‡∏° platforms ‡πÅ‡∏•‡∏∞ task types |

### ‚ùå ‡∏™‡∏¥‡πà‡∏á‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÉ‡∏´‡∏°‡πà

1. **Platform Workers ‡πÉ‡∏´‡∏°‡πà**
   - FreepikWorker
   - RunwayWorker
   - PikaLabsWorker
   - LumaAIWorker
   - SunoAIWorker

2. **Media Processing Services**
   - FFmpegService
   - VideoProcessor
   - AudioProcessor
   - MixingService

3. **New Task Types**
   - GenerateVideo
   - GenerateMusic
   - ProcessVideo
   - MixVideoWithMusic

4. **API Endpoints**
   - VideoGenerationController
   - MusicGenerationController
   - MediaProcessingController

5. **UI Components**
   - VideoGenerationPage
   - MusicGenerationPage
   - MediaLibraryPage

---

## ‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á‡πÉ‡∏ô Core Models

### 1. ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó `Enums.cs`

```csharp
/// <summary>
/// Supported platforms (Thailand + AI Services)
/// </summary>
public enum SocialPlatform
{
    // Social Media (existing)
    Facebook,
    Instagram,
    TikTok,
    Twitter,
    Line,
    YouTube,
    Threads,
    LinkedIn,
    Pinterest,

    // AI Video Generation (NEW)
    Freepik,       // Freepik Pikaso AI
    Runway,        // Runway ML
    PikaLabs,      // Pika Labs
    LumaAI,        // Luma Dream Machine

    // AI Music Generation (NEW)
    SunoAI         // Suno AI Music
}

/// <summary>
/// Types of tasks (extended)
/// </summary>
public enum TaskType
{
    // Content Generation (existing)
    GenerateContent,
    GenerateImage,

    // AI Media Generation (NEW)
    GenerateVideo,              // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ß‡∏µ‡∏î‡∏µ‡πÇ‡∏≠‡∏î‡πâ‡∏ß‡∏¢ AI
    GenerateMusic,              // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÄ‡∏û‡∏•‡∏á‡∏î‡πâ‡∏ß‡∏¢ AI
    ProcessVideo,               // ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏ß‡∏µ‡∏î‡∏µ‡πÇ‡∏≠
    ProcessAudio,               // ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡πÄ‡∏™‡∏µ‡∏¢‡∏á
    MixVideoWithMusic,          // ‡∏ú‡∏™‡∏°‡∏ß‡∏µ‡∏î‡∏µ‡πÇ‡∏≠‡∏Å‡∏±‡∏ö‡πÄ‡∏û‡∏•‡∏á
    ConcatenateVideos,          // ‡∏ï‡πà‡∏≠‡∏Ñ‡∏•‡∏¥‡∏õ‡∏ß‡∏µ‡∏î‡∏µ‡πÇ‡∏≠
    ExtractAudioFromVideo,      // ‡πÅ‡∏¢‡∏Å‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏à‡∏≤‡∏Å‡∏ß‡∏µ‡∏î‡∏µ‡πÇ‡∏≠
    GenerateThumbnail,          // ‡∏™‡∏£‡πâ‡∏≤‡∏á thumbnail

    // Posting (existing)
    PostContent,
    SchedulePost,
    PostToGroup,
    PostToMultipleGroups,

    // ... (existing types)
}

/// <summary>
/// Video generation modes (NEW)
/// </summary>
public enum VideoGenerationMode
{
    TextToVideo,       // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏à‡∏≤‡∏Å‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°
    ImageToVideo,      // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏à‡∏≤‡∏Å‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û
    VideoToVideo,      // ‡πÅ‡∏õ‡∏•‡∏á‡∏ß‡∏µ‡∏î‡∏µ‡πÇ‡∏≠
    ExpandCanvas       // ‡∏Ç‡∏¢‡∏≤‡∏¢ canvas
}

/// <summary>
/// Aspect ratios (NEW)
/// </summary>
public enum AspectRatio
{
    Landscape_16_9,    // 16:9 - YouTube, Landscape
    Portrait_9_16,     // 9:16 - TikTok, Reels, Stories
    Square_1_1,        // 1:1 - Instagram Feed
    Classic_4_3,       // 4:3 - Classic
    Ultrawide_21_9     // 21:9 - Ultrawide
}

/// <summary>
/// Video quality levels (NEW)
/// </summary>
public enum VideoQuality
{
    Low_480p,
    Medium_720p,
    High_1080p,
    Ultra_4K
}

/// <summary>
/// Music genres (NEW)
/// </summary>
public enum MusicGenre
{
    Pop,
    Rock,
    Electronic,
    HipHop,
    Jazz,
    Classical,
    Ambient,
    Cinematic,
    LoFi,
    Acoustic
}
```

---

### 2. ‡πÄ‡∏û‡∏¥‡πà‡∏° Properties ‡πÉ‡∏ô `TaskItem.cs`

```csharp
public class TaskItem
{
    // Existing properties...

    // NEW: Video Generation Properties
    public VideoGenerationConfig? VideoConfig { get; set; }

    // NEW: Music Generation Properties
    public MusicGenerationConfig? MusicConfig { get; set; }

    // NEW: Media Processing Properties
    public MediaProcessingConfig? ProcessingConfig { get; set; }
}

/// <summary>
/// Configuration for video generation (NEW)
/// </summary>
public class VideoGenerationConfig
{
    public VideoGenerationMode Mode { get; set; }
    public string Prompt { get; set; } = string.Empty;
    public string? NegativePrompt { get; set; }
    public int Duration { get; set; } = 5; // seconds
    public AspectRatio AspectRatio { get; set; } = AspectRatio.Landscape_16_9;
    public VideoQuality Quality { get; set; } = VideoQuality.High_1080p;
    public int Fps { get; set; } = 30;
    public string? SourceImageUrl { get; set; }
    public string? SourceVideoUrl { get; set; }
    public int? Seed { get; set; }
    public int NumberOfOutputs { get; set; } = 1;
    public double Strength { get; set; } = 0.8; // 0-1
    public Dictionary<string, object>? ProviderSpecific { get; set; }
}

/// <summary>
/// Configuration for music generation (NEW)
/// </summary>
public class MusicGenerationConfig
{
    public string Prompt { get; set; } = string.Empty;
    public int Duration { get; set; } = 30; // seconds
    public MusicGenre? Genre { get; set; }
    public string? Mood { get; set; }
    public bool Instrumental { get; set; } = false;
    public string? Lyrics { get; set; }
}

/// <summary>
/// Configuration for media processing (NEW)
/// </summary>
public class MediaProcessingConfig
{
    public string? VideoPath { get; set; }
    public string? AudioPath { get; set; }
    public string? OutputFormat { get; set; } = "mp4";
    public VideoQuality? OutputQuality { get; set; }
    public bool MixAudio { get; set; } = false;
    public double AudioVolume { get; set; } = 1.0; // 0-1
    public List<string>? VideosToConcat { get; set; }
    public bool GenerateThumbnail { get; set; } = true;
}
```

---

### 3. ‡πÄ‡∏û‡∏¥‡πà‡∏° Properties ‡πÉ‡∏ô `TaskResult.cs`

```csharp
public class TaskResult
{
    // Existing properties...

    // NEW: Media generation results
    public MediaGenerationResult? MediaResult { get; set; }
}

/// <summary>
/// Result from media generation (NEW)
/// </summary>
public class MediaGenerationResult
{
    public string? VideoUrl { get; set; }
    public string? VideoPath { get; set; }
    public string? AudioUrl { get; set; }
    public string? AudioPath { get; set; }
    public string? ThumbnailUrl { get; set; }
    public VideoMetadata? Metadata { get; set; }
}

/// <summary>
/// Video metadata (NEW)
/// </summary>
public class VideoMetadata
{
    public int Width { get; set; }
    public int Height { get; set; }
    public double Duration { get; set; } // seconds
    public int Fps { get; set; }
    public long FileSize { get; set; } // bytes
    public string Format { get; set; } = string.Empty;
    public string? Codec { get; set; }
    public long? Bitrate { get; set; }
    public Dictionary<string, object>? Extra { get; set; }
}
```

---

## Platform Workers ‡πÉ‡∏´‡∏°‡πà

### 1. FreepikWorker.cs (PRIMARY)

```csharp
using AIManager.Core.Models;
using AIManager.Core.WebAutomation;
using Microsoft.Extensions.Logging;

namespace AIManager.Core.Workers;

/// <summary>
/// Freepik Pikaso AI Worker
/// Primary video generation provider
/// Uses Web Learning for automation
/// </summary>
public class FreepikWorker : BasePlatformWorker
{
    private readonly BrowserController _browser;
    private readonly WorkflowLearningEngine _learningEngine;
    private readonly WorkflowExecutor _executor;
    private const string PikasoUrl = "https://www.freepik.com/pikaso/ai-video-generator";

    public override SocialPlatform Platform => SocialPlatform.Freepik;

    public FreepikWorker(
        BrowserController browser,
        WorkflowLearningEngine learningEngine,
        WorkflowExecutor executor,
        ILogger<FreepikWorker> logger) : base(logger)
    {
        _browser = browser;
        _learningEngine = learningEngine;
        _executor = executor;
    }

    public override async Task<TaskResult> PostContentAsync(TaskItem task, CancellationToken ct)
    {
        var sw = System.Diagnostics.Stopwatch.StartNew();

        try
        {
            var videoConfig = task.VideoConfig;
            if (videoConfig == null)
            {
                return new TaskResult
                {
                    Success = false,
                    Error = "Missing video configuration"
                };
            }

            _logger.LogInformation("Starting video generation with Freepik Pikaso AI");
            _logger.LogInformation("Prompt: {Prompt}", videoConfig.Prompt);

            // Initialize browser
            await _browser.LaunchAsync(headless: true);
            await _browser.NavigateAsync(PikasoUrl);

            // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏°‡∏µ workflow ‡∏ó‡∏µ‡πà‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡∏£‡∏π‡πâ‡πÑ‡∏ß‡πâ‡πÅ‡∏•‡πâ‡∏ß‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
            var workflowType = "generate_video";
            var existingWorkflow = await _learningEngine.FindWorkflowAsync(
                Platform.ToString(),
                workflowType
            );

            string? videoUrl = null;

            if (existingWorkflow != null && existingWorkflow.ConfidenceScore >= 0.7)
            {
                _logger.LogInformation("Using learned workflow (confidence: {Confidence})",
                    existingWorkflow.ConfidenceScore);

                // Execute learned workflow
                var result = await _executor.ExecuteAsync(
                    existingWorkflow,
                    new Dictionary<string, object>
                    {
                        ["prompt"] = videoConfig.Prompt,
                        ["duration"] = videoConfig.Duration,
                        ["aspectRatio"] = videoConfig.AspectRatio.ToString()
                    }
                );

                if (result.Success)
                {
                    videoUrl = await ExtractVideoUrlAsync();
                }
                else
                {
                    _logger.LogWarning("Workflow execution failed, entering learning mode");
                    videoUrl = await LearnAndGenerateAsync(videoConfig);
                }
            }
            else
            {
                _logger.LogInformation("No learned workflow found, entering learning mode");
                videoUrl = await LearnAndGenerateAsync(videoConfig);
            }

            if (string.IsNullOrEmpty(videoUrl))
            {
                return new TaskResult
                {
                    Success = false,
                    Error = "Failed to generate video"
                };
            }

            // Download video
            var videoPath = await DownloadVideoAsync(videoUrl, task.Id);

            // Extract metadata using FFmpeg
            var metadata = await ExtractMetadataAsync(videoPath);

            return new TaskResult
            {
                Success = true,
                Data = new ResultData
                {
                    PostId = task.Id,
                    PlatformUrl = videoUrl
                },
                MediaResult = new MediaGenerationResult
                {
                    VideoUrl = videoUrl,
                    VideoPath = videoPath,
                    Metadata = metadata
                },
                ProcessingTimeMs = sw.ElapsedMilliseconds
            };
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error generating video with Freepik");
            return new TaskResult
            {
                Success = false,
                Error = ex.Message,
                ProcessingTimeMs = sw.ElapsedMilliseconds
            };
        }
        finally
        {
            await _browser.CloseAsync();
        }
    }

    /// <summary>
    /// ‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡∏£‡∏π‡πâ workflow ‡πÉ‡∏´‡∏°‡πà‡πÅ‡∏•‡∏∞‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ß‡∏µ‡∏î‡∏µ‡πÇ‡∏≠
    /// </summary>
    private async Task<string?> LearnAndGenerateAsync(VideoGenerationConfig config)
    {
        // ‡∏™‡∏£‡πâ‡∏≤‡∏á teaching session
        var session = await _learningEngine.StartTeachingSessionAsync(
            Platform.ToString(),
            "generate_video"
        );

        // ‡πÄ‡∏£‡∏¥‡πà‡∏° recording
        await _browser.StartRecordingAsync();

        // AI ‡∏à‡∏∞‡∏ä‡πà‡∏ß‡∏¢‡∏´‡∏≤ elements ‡πÅ‡∏•‡∏∞‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥

        // 1. ‡∏´‡∏≤ prompt input field
        var promptInput = await _browser.FindElementAsync(new[] {
            "textarea[placeholder*='prompt' i]",
            "textarea[placeholder*='describe' i]",
            "input[type='text'][placeholder*='prompt' i]",
            "div[contenteditable='true']",
            "[data-testid*='prompt']"
        });

        if (promptInput == null)
        {
            throw new Exception("Cannot find prompt input field");
        }

        await _browser.TypeAsync(promptInput, config.Prompt, humanLike: true);
        await Task.Delay(1000);

        // 2. ‡∏´‡∏≤ generate button
        var generateButton = await _browser.FindElementAsync(new[] {
            "button:has-text('Generate')",
            "button:has-text('Create')",
            "[data-testid*='generate']",
            "[aria-label*='generate' i]"
        });

        if (generateButton == null)
        {
            throw new Exception("Cannot find generate button");
        }

        await _browser.ClickAsync(generateButton);

        // 3. ‡∏£‡∏≠‡∏à‡∏ô‡∏Å‡∏ß‡πà‡∏≤‡∏ß‡∏µ‡∏î‡∏µ‡πÇ‡∏≠‡∏à‡∏∞‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÄ‡∏™‡∏£‡πá‡∏à
        await _browser.WaitForSelectorAsync("video, [data-testid*='video']", timeout: 300000);

        // ‡∏´‡∏¢‡∏∏‡∏î recording
        var recordedSteps = await _browser.StopRecordingAsync();

        // ‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡∏£‡∏π‡πâ‡∏à‡∏≤‡∏Å recorded steps
        var workflow = await _learningEngine.LearnFromTeachingSessionAsync(
            session.Id,
            recordedSteps
        );

        _logger.LogInformation("Learned new workflow with {StepCount} steps", workflow.Steps.Count);

        // Extract video URL
        return await ExtractVideoUrlAsync();
    }

    /// <summary>
    /// ‡∏î‡∏∂‡∏á video URL ‡∏à‡∏≤‡∏Å‡∏´‡∏ô‡πâ‡∏≤‡πÄ‡∏ß‡πá‡∏ö
    /// </summary>
    private async Task<string?> ExtractVideoUrlAsync()
    {
        // ‡∏•‡∏≠‡∏á extract ‡∏à‡∏≤‡∏Å video element
        var videoSrc = await _browser.EvaluateAsync<string>(@"
            const video = document.querySelector('video');
            return video ? video.src : null;
        ");

        if (!string.IsNullOrEmpty(videoSrc))
        {
            return videoSrc;
        }

        // ‡∏•‡∏≠‡∏á extract ‡∏à‡∏≤‡∏Å download link
        var downloadHref = await _browser.EvaluateAsync<string>(@"
            const link = document.querySelector('a[download], a[href*="".mp4""]');
            return link ? link.href : null;
        ");

        return downloadHref;
    }

    /// <summary>
    /// ‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î‡∏ß‡∏µ‡∏î‡∏µ‡πÇ‡∏≠
    /// </summary>
    private async Task<string> DownloadVideoAsync(string url, string taskId)
    {
        var outputDir = Path.Combine(AppContext.BaseDirectory, "downloads", "videos");
        Directory.CreateDirectory(outputDir);

        var filename = $"{taskId}.mp4";
        var outputPath = Path.Combine(outputDir, filename);

        using var httpClient = new HttpClient();
        var response = await httpClient.GetAsync(url);
        response.EnsureSuccessStatusCode();

        await using var fs = new FileStream(outputPath, FileMode.Create);
        await response.Content.CopyToAsync(fs);

        _logger.LogInformation("Downloaded video to {Path}", outputPath);

        return outputPath;
    }

    /// <summary>
    /// Extract metadata using FFmpeg
    /// </summary>
    private async Task<VideoMetadata> ExtractMetadataAsync(string videoPath)
    {
        // TODO: Implement FFmpeg metadata extraction
        // For now, return basic metadata
        var fileInfo = new FileInfo(videoPath);

        return new VideoMetadata
        {
            Width = 1920,
            Height = 1080,
            Duration = 5,
            Fps = 30,
            FileSize = fileInfo.Length,
            Format = "mp4"
        };
    }
}
```

**‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏**: Workers ‡∏≠‡∏∑‡πà‡∏ô‡πÜ (Runway, Pika, Luma, Suno) ‡∏à‡∏∞‡∏°‡∏µ‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ñ‡∏•‡πâ‡∏≤‡∏¢‡∏Å‡∏±‡∏ô ‡πÅ‡∏Ñ‡πà‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô URL ‡πÅ‡∏•‡∏∞ element selectors

---

## FFmpeg Integration

‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå‡πÅ‡∏•‡∏∞‡πÑ‡∏ü‡∏•‡πå‡πÉ‡∏´‡∏°‡πà:

```
AIManagerCore/src/AIManager.Core/MediaProcessing/
‚îú‚îÄ‚îÄ FFmpegService.cs
‚îú‚îÄ‚îÄ VideoProcessor.cs
‚îú‚îÄ‚îÄ AudioProcessor.cs
‚îî‚îÄ‚îÄ MixingService.cs
```

### FFmpegService.cs

```csharp
using System.Diagnostics;
using Microsoft.Extensions.Logging;

namespace AIManager.Core.MediaProcessing;

/// <summary>
/// FFmpeg integration service
/// Handles video and audio processing
/// </summary>
public class FFmpegService
{
    private readonly ILogger<FFmpegService> _logger;
    private readonly string _ffmpegPath;
    private readonly string _ffprobePath;

    public FFmpegService(ILogger<FFmpegService> logger)
    {
        _logger = logger;
        _ffmpegPath = FindFFmpeg();
        _ffprobePath = FindFFprobe();
    }

    /// <summary>
    /// Extract video metadata
    /// </summary>
    public async Task<VideoMetadata> GetMetadataAsync(string videoPath)
    {
        var args = $"-v quiet -print_format json -show_format -show_streams \"{videoPath}\"";
        var output = await RunFFprobeAsync(args);

        // Parse JSON output
        var json = System.Text.Json.JsonDocument.Parse(output);
        var format = json.RootElement.GetProperty("format");
        var videoStream = json.RootElement.GetProperty("streams")
            .EnumerateArray()
            .FirstOrDefault(s => s.GetProperty("codec_type").GetString() == "video");

        return new VideoMetadata
        {
            Duration = double.Parse(format.GetProperty("duration").GetString() ?? "0"),
            FileSize = long.Parse(format.GetProperty("size").GetString() ?? "0"),
            Format = format.GetProperty("format_name").GetString() ?? "unknown",
            Width = videoStream.GetProperty("width").GetInt32(),
            Height = videoStream.GetProperty("height").GetInt32(),
            Fps = EvaluateFrameRate(videoStream.GetProperty("r_frame_rate").GetString() ?? "30/1"),
            Codec = videoStream.GetProperty("codec_name").GetString(),
            Bitrate = long.TryParse(format.GetProperty("bit_rate").GetString(), out var br) ? br : null
        };
    }

    /// <summary>
    /// Convert video to different format/quality
    /// </summary>
    public async Task<string> ConvertVideoAsync(
        string inputPath,
        string outputPath,
        VideoQuality quality = VideoQuality.High_1080p,
        string codec = "libx264")
    {
        var resolution = quality switch
        {
            VideoQuality.Low_480p => "854:480",
            VideoQuality.Medium_720p => "1280:720",
            VideoQuality.High_1080p => "1920:1080",
            VideoQuality.Ultra_4K => "3840:2160",
            _ => "1920:1080"
        };

        var args = $"-i \"{inputPath}\" -vf scale={resolution} -c:v {codec} -preset medium -crf 23 -c:a aac -b:a 128k \"{outputPath}\"";

        await RunFFmpegAsync(args);

        return outputPath;
    }

    /// <summary>
    /// Mix video with audio
    /// </summary>
    public async Task<string> MixVideoWithAudioAsync(
        string videoPath,
        string audioPath,
        string outputPath,
        double audioVolume = 1.0)
    {
        var args = $"-i \"{videoPath}\" -i \"{audioPath}\" -c:v copy -c:a aac -filter:a \"volume={audioVolume}\" -shortest \"{outputPath}\"";

        await RunFFmpegAsync(args);

        return outputPath;
    }

    /// <summary>
    /// Concatenate multiple videos
    /// </summary>
    public async Task<string> ConcatenateVideosAsync(
        List<string> videoPaths,
        string outputPath)
    {
        // ‡∏™‡∏£‡πâ‡∏≤‡∏á concat file
        var concatFile = Path.GetTempFileName();
        var concatContent = string.Join("\n", videoPaths.Select(p => $"file '{p}'"));
        await File.WriteAllTextAsync(concatFile, concatContent);

        var args = $"-f concat -safe 0 -i \"{concatFile}\" -c copy \"{outputPath}\"";

        await RunFFmpegAsync(args);

        File.Delete(concatFile);

        return outputPath;
    }

    /// <summary>
    /// Generate thumbnail
    /// </summary>
    public async Task<string> GenerateThumbnailAsync(
        string videoPath,
        string outputPath,
        double timeOffset = 1.0)
    {
        var args = $"-ss {timeOffset} -i \"{videoPath}\" -vframes 1 \"{outputPath}\"";

        await RunFFmpegAsync(args);

        return outputPath;
    }

    /// <summary>
    /// Extract audio from video
    /// </summary>
    public async Task<string> ExtractAudioAsync(
        string videoPath,
        string outputPath)
    {
        var args = $"-i \"{videoPath}\" -vn -acodec libmp3lame -q:a 2 \"{outputPath}\"";

        await RunFFmpegAsync(args);

        return outputPath;
    }

    private async Task<string> RunFFmpegAsync(string arguments)
    {
        return await RunProcessAsync(_ffmpegPath, arguments);
    }

    private async Task<string> RunFFprobeAsync(string arguments)
    {
        return await RunProcessAsync(_ffprobePath, arguments);
    }

    private async Task<string> RunProcessAsync(string filename, string arguments)
    {
        var psi = new ProcessStartInfo
        {
            FileName = filename,
            Arguments = arguments,
            RedirectStandardOutput = true,
            RedirectStandardError = true,
            UseShellExecute = false,
            CreateNoWindow = true
        };

        using var process = Process.Start(psi);
        if (process == null)
        {
            throw new Exception($"Failed to start {filename}");
        }

        var output = await process.StandardOutput.ReadToEndAsync();
        var error = await process.StandardError.ReadToEndAsync();

        await process.WaitForExitAsync();

        if (process.ExitCode != 0)
        {
            _logger.LogError("FFmpeg error: {Error}", error);
            throw new Exception($"FFmpeg failed: {error}");
        }

        return output;
    }

    private string FindFFmpeg()
    {
        // Try common locations
        var paths = new[]
        {
            "ffmpeg",
            "ffmpeg.exe",
            @"C:\ffmpeg\bin\ffmpeg.exe",
            "/usr/bin/ffmpeg",
            "/usr/local/bin/ffmpeg"
        };

        foreach (var path in paths)
        {
            if (File.Exists(path) || IsInPath(path))
            {
                return path;
            }
        }

        throw new Exception("FFmpeg not found. Please install FFmpeg and add it to PATH");
    }

    private string FindFFprobe()
    {
        return FindFFmpeg().Replace("ffmpeg", "ffprobe");
    }

    private bool IsInPath(string command)
    {
        try
        {
            var psi = new ProcessStartInfo
            {
                FileName = command,
                Arguments = "-version",
                RedirectStandardOutput = true,
                UseShellExecute = false,
                CreateNoWindow = true
            };

            using var process = Process.Start(psi);
            return process != null;
        }
        catch
        {
            return false;
        }
    }

    private int EvaluateFrameRate(string frameRate)
    {
        var parts = frameRate.Split('/');
        if (parts.Length == 2 &&
            int.TryParse(parts[0], out var num) &&
            int.TryParse(parts[1], out var den) &&
            den != 0)
        {
            return num / den;
        }
        return 30;
    }
}
```

---

## ‡∏™‡∏£‡∏∏‡∏õ

‡∏Å‡∏≤‡∏£‡∏û‡∏±‡∏í‡∏ô‡∏≤‡∏ï‡πà‡∏≠‡∏¢‡∏≠‡∏î‡∏£‡∏∞‡∏ö‡∏ö‡πÄ‡∏î‡∏¥‡∏°‡∏à‡∏∞:

‚úÖ **‡πÉ‡∏ä‡πâ‡∏ã‡πâ‡∏≥** Web Learning System ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
‚úÖ **‡πÄ‡∏û‡∏¥‡πà‡∏°** Platform Workers ‡πÉ‡∏´‡∏°‡πà (Freepik, Runway, Pika, Luma, Suno)
‚úÖ **‡πÄ‡∏û‡∏¥‡πà‡∏°** FFmpeg Integration ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö video processing
‚úÖ **‡∏Ç‡∏¢‡∏≤‡∏¢** Enums ‡πÅ‡∏•‡∏∞ Models ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö video/music generation
‚úÖ **‡πÄ‡∏û‡∏¥‡πà‡∏°** API Endpoints ‡πÅ‡∏•‡∏∞ UI Components

**‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÉ‡∏´‡∏°‡πà‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î** - ‡∏õ‡∏£‡∏∞‡∏´‡∏¢‡∏±‡∏î‡πÄ‡∏ß‡∏•‡∏≤‡πÅ‡∏•‡∏∞‡πÉ‡∏ä‡πâ‡∏õ‡∏£‡∏∞‡πÇ‡∏¢‡∏ä‡∏ô‡πå‡∏à‡∏≤‡∏Å‡πÇ‡∏Ñ‡πä‡∏î‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß! üöÄ

---

**Next Steps**: ‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÉ‡∏´‡πâ‡∏ú‡∏°‡πÄ‡∏£‡∏¥‡πà‡∏° implement ‡∏à‡∏≤‡∏Å‡∏™‡πà‡∏ß‡∏ô‡πÑ‡∏´‡∏ô‡∏Å‡πà‡∏≠‡∏ô‡∏Ñ‡∏£‡∏±‡∏ö?

1. FreepikWorker
2. FFmpegService
3. API Controllers
4. UI Components
5. Tests

‡∏ö‡∏≠‡∏Å‡∏ú‡∏°‡πÑ‡∏î‡πâ‡πÄ‡∏•‡∏¢‡∏Ñ‡∏£‡∏±‡∏ö! üí™
